Spark BroadCastVariable
1. val boringWords = sc.broadcast(loadBoringData())
        store the broadcast variable , i.e shared across all the nodes
            a. this is helpful to join
            b.Can be used to reference data
2.flatMapValues(x=>x.split(" "))
        1. if sentence has multiple words "hello how are you ?" , you can use flat map to split them and join them
        for the same key
3. reduceByKey((x,y)=>x+y)
        1. Based on the key you can reduce all the values i.e (good,23), (good,26) => good(49)

4. map(x=>(x.split(",")(10).toFloat,x.split(",")(0)))
    1. You can use split in the map and get the key value pair as well


Accumulator
1. A shared variable that all the nodes  can  update the counter .Its kept in driver machine
2.Executors cannot read the value , but can update the value -> same as counters in the MapReduce

1. Accumulator-> single copy on driver machine
2. broadcast variable -> separate copy in each machine



Narrow Transformation : No Shuffling is required
    1. map
    2.flatmap
    3.Filter


Wide Transformation: Shuffling is required
    1.reduceByKey


 Stage :
    1. marked by shuffle boundaries
        when ever we encounter new shuffle( wide transform) spark creates stage
           total number of stages = basic stage(1) + number of new shuffles
           eg 3 suffles => 1+ 3 = 4 stages

Difference between reduce by key and reduce
1.reducebykey -> transformation (wide)
2.reduce -> action


groupByKey vs reduceBykey

1. Both are wide transformation

reduceBykey
1.More working in parallel
2.less shuffling is required
3.Local aggrigation happens

groupByKey
1.Shuffling is required
2.We donot get local aggrigation
3.All the key values are sent (shuffled) to another machine
4.Shuffle more data and less parallelism

never use groupbyKey if you can use reduceByKey
